Zadanie 1

Uruchom podane przyk≈Çady:

a)

main :: IO ()
main = do
  let x = takeWhile (<50) (map kw [0..])
  print(x)

kw :: Integer -> Integer
kw x = x*x

üß† CO SIƒò TU DZIEJE:
[0..] to niesko≈Ñczona lista liczb naturalnych

map kw [0..] przekszta≈Çca jƒÖ na [0*0, 1*1, 2*2, ...] ‚Üí [0,1,4,9,16,25,36,49,64,81,...]

takeWhile (<50) zatrzymuje przetwarzanie w momencie, gdy pierwszy element nie spe≈Çni warunku (czyli 64 ‚â• 50)


b)
main :: IO ()
main = do
  let y = kw (snd ([1..],5))
  print(y)

kw :: Integer -> Integer
kw x = x*x

üß† CO SIƒò TU DZIEJE:
[1..] to znowu niesko≈Ñczona lista

[1..], 5 to para (niesko≈Ñczona lista, liczba 5)

snd wyciƒÖga drugƒÖ warto≈õƒá z pary, czyli 5

kw 5 = 25

Zadanie 2

Uruchom poni≈ºszy przyk≈Çad:

data Tree a = EmptyTree | Node a (Tree a) (Tree a)
emptyTree :: Tree Int 
emptyTree = EmptyTree 

singleNode :: Tree Int 
singleNode = Node 5 EmptyTree EmptyTree 

exampleTree :: Tree Int
exampleTree = Node 10 (Node 5 EmptyTree EmptyTree) (Node 15 (Node 12 EmptyTree EmptyTree) EmptyTree)

sumTree :: Num a => Tree a -> a 
sumTree EmptyTree = 0 
sumTree (Node value left right) = value + sumTree left + sumTree right

main :: IO ()
main = do
  print(sumTree exampleTree)
Opisz dzia≈Çanie typ√≥w rekurencyjnych w Haskelu.


Tree a to typ drzewa z wartosciami typu a.
Moze byc: EmptyTree - pusty
Node a left right - z wartoscia a i dwoma poddrzewami left, right

sumTree:
Jak dzia≈Ça?

Je≈õli drzewo jest puste ‚Äì zwr√≥ƒá 0 (to jest baza rekurencji)

Je≈õli to Node, to:

dodaj value (czyli warto≈õƒá tego wƒôz≈Ça),

dodaj sumƒô lewej ga≈Çƒôzi (sumTree left),

dodaj sumƒô prawej (sumTree right)

Zadanie 3

Napisz funkcjƒô, kt√≥ra pobiera listƒô i zwraca tƒô samƒÖ listƒô z elementami w odwr√≥conej kolejno≈õci, nie korzystajƒÖc z gotowej funkcji reverse.

myReverse :: [a] -> [a]
myReverse [] = []
myReverse (x:xs) = myReverse xs ++ [x]

Zadanie 4

Skorzystaj z mechanizmu sk≈Çadania list w celu utworzenia tabliczki mno≈ºenia. Tabela powinna byƒá listƒÖ z≈Ço≈ºonƒÖ z tr√≥jelementowych krotek. Pierwsze dwa elementy to liczby z zakresu 1..12, a trzeci to ich iloczyn.

multiplicationTable :: [(Int, Int, Int)]
multiplicationTable = [ (x, y, x * y) | x <- [1..12], y <- [1..12] ]
main :: IO ()
main = do
  putStrLn "Tabliczka mno≈ºenia (1 do 12):"
  mapM_ print multiplicationTable


Zadanie 5
Napisz funkcjƒô, kt√≥ra generuje dwuelementowe krotki z wszystkimi mo≈ºliwymi kombinacjami dw√≥ch kolor√≥w ze zbioru {black, white, blue, yellow, red}. Wyeliminuj wyniki typu (red,red) oraz powt√≥rzenia typu (red, yellow) - (yellow, red).

-- Lista kolor√≥w
colors :: [String]
colors = ["black", "white", "blue", "yellow", "red"]

-- Generowanie unikalnych par kolor√≥w bez powt√≥rze≈Ñ i duplikat√≥w
uniqueColorPairs :: [(String, String)]
uniqueColorPairs = [ (c1, c2) | (i, c1) <- indexedColors, (j, c2) <- indexedColors, i < j ]
  where
    indexedColors = zip [0..] colors
    -- Dodajemy indeksy do kolor√≥w, ≈ºeby m√≥c por√≥wnywaƒá kolejno≈õƒá i wykluczyƒá (c2, c1)

-- Funkcja main wypisuje wynik
main :: IO ()
main = do
  putStrLn "Unikalne kombinacje dw√≥ch kolor√≥w:"
  mapM_ print uniqueColorPairs


Zadanie 6

Napisz nastƒôpujƒÖce funkcje dla list:

a) append l m , kt√≥ra konkatenuje listy l i m,

append :: [a] -> [a] -> [a]
append [] ys = ys
append (x:xs) ys = x : append xs ys

b) member x l , kt√≥ra sprawdza, czy x jest elementem listy l,
member :: Eq a => a -> [a] -> Bool
member _ [] = False
member x (y:ys)
  | x == y    = True
  | otherwise = member x ys

c) last l, kt√≥ra znajduje ostatni element w li≈õcie,
last :: [a] -> a
last [] = error "Lista jest pusta ‚Äì nie ma ostatniego elementu"
last [x] = x
last (_:xs) = last xs


d) delete x l, kt√≥ra skasuje element x z listy l
delete :: Eq a => a -> [a] -> [a]
delete _ [] = []
delete x (y:ys)
  | x == y    = ys           -- trafili≈õmy: pomijamy ten element
  | otherwise = y : delete x ys  -- nie trafili≈õmy: zostawiamy i szukamy dalej


e) split x l , kt√≥ra podzieli listƒô l do dw√≥ch list l1 i l2. l1 zawiera elementy mniejsze ni≈º x a l2 elementy wiƒôksze ni≈º x.
-- Funkcja split: dzieli listƒô na elementy mniejsze i wiƒôksze od x
split :: Ord a => a -> [a] -> ([a], [a])
split _ [] = ([], [])
split x (y:ys)
  | y < x     = (y : l1, l2)
  | y > x     = (l1, y : l2)
  | otherwise = (l1, l2)
  where
    (l1, l2) = split x ys

-- Funkcja main testuje split na r√≥≈ºnych danych
main :: IO ()
main = do
  putStrLn "Test 1:"
  print (split 5 [1, 7, 3, 5, 8, 2, 5, 0, 10])
  -- ([1,3,2,0],[7,8,10])

  putStrLn "Test 2:"
  print (split 4 [4, 4, 4])
  -- ([],[])

  putStrLn "Test 3:"
  print (split 0 [1, 2, 3])
  -- ([],[1,2,3])

  putStrLn "Test 4:"
  print (split 10 [20, 5, 10, 1])
  -- ([5,1],[20])


Zadanie 7

Napisz funkcjƒô filter p l, kt√≥rej warto≈õciƒÖ zwracanƒÖ jest lista wszystkich element√≥w listy l , kt√≥re spe≈ÇniƒÖ predykat p. Jaki ma typ funkcja filter?
filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter p (x:xs)
  | p x       = x : filter p xs
  | otherwise = filter p xs

Zadanie 8

Napisz funkcjƒô onlyEven, kt√≥ra przyjmuje listƒô liczb ca≈Çkowitych i zwraca listƒô zawierajƒÖcƒÖ tylko liczby parzyste.
onlyEven :: [Int] -> [Int]
onlyEven xs = [x | x <- xs, even x]
main :: IO ()
main = do
  putStrLn "Liczby parzyste z listy:"
  print (onlyEven [1..10])         -- [2,4,6,8,10]
  print (onlyEven [5,7,9])         -- []
  print (onlyEven [2,4,6,8,10])    -- [2,4,6,8,10]

-- Funkcja onlyEven: zwraca tylko liczby parzyste
onlyEven :: [Int] -> [Int]
onlyEven xs = [x | x <- xs, even x]

-- Alternatywa z filter:
-- onlyEven = filter even

-- Przyk≈Çadowe testy
main :: IO ()
main = do
  putStrLn "Liczby parzyste z listy:"
  print (onlyEven [1..10])
  print (onlyEven [5,7,9])
  print (onlyEven [2,4,6,8,10])

Zadanie 9

Napisz funkcjƒô doubleAll, kt√≥ra przyjmuje listƒô liczb ca≈Çkowitych i zwraca listƒô, w kt√≥rej ka≈ºda liczba jest podwojona.

doubleAll :: [Int] -> [Int]
doubleAll xs = [x * 2 | x <- xs]

-- Funkcja doubleAll: podwaja ka≈ºdƒÖ liczbƒô w li≈õcie
doubleAll :: [Int] -> [Int]
doubleAll xs = [x * 2 | x <- xs]

-- Alternatywa:
-- doubleAll = map (*2)

-- Przyk≈Çadowe testy
main :: IO ()
main = do
  putStrLn "Podwajanie wszystkich liczb:"
  print (doubleAll [1, 2, 3])
  print (doubleAll [0, -1, 10])
  print (doubleAll [])

Zadanie 10

Napisz funkcjƒô sumOfDigits, kt√≥ra dla danej liczby ca≈Çkowitej zwr√≥ci sumƒô jej cyfr.

import Data.Char (digitToInt)

-- Funkcja sumujƒÖca cyfry liczby
sumOfDigits :: Integer -> Int
sumOfDigits n = sum $ map digitToInt $ show $ abs n

-- Przyk≈Çadowe testy
main :: IO ()
main = do
  print (sumOfDigits 1234)     -- 10
  print (sumOfDigits (-567))   -- 18
  print (sumOfDigits 0)        -- 0













