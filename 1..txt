1. 
Zadanie 1

Skompiluj poniÅ¼szy program:



rodzice(uranus, gaia, rhea).
rodzice(uranus, gaia, cronus).
rodzice(cronus, rhea, zeus).
rodzice(cronus, rhea, hera).
rodzice(cronus, rhea, demeter).
rodzice(zeus, leto, artemis).
rodzice(zeus, leto, apollo).
rodzice(zeus, demeter, persephone).

ojciec(X, Y) :- rodzice(X, _, Y).
matka(X, Y) :- rodzice(_, X, Y).

rodzic(X, Y) :- ojciec(X, Y); matka(X, Y).

dziadek(X, Z) :- ojciec(X, Y), rodzic(Y, Z).
babcia(X, Z) :- matka(X, Y), rodzic(Y, Z).
rodzic(X, zeus).


Zadanie 2

Napisz program w Prologu, ktÃ³ry pozwoli na pokolorowanie piÄ™ciu sÄ…siadujÄ…cych ze sobÄ… wojewÃ³dztw (Podkarpackie, Lubelskie, Mazowieckie, Podlaskie i WarmiÅ„sko-Mazurskie), w taki sposÃ³b, aby wojewÃ³dztwa ktÃ³re sÄ… sÄ…siadami, nie posiadaÅ‚y tego samego koloru. UÅ¼yj w tym celu tylko trzech kolorÃ³w.

2. % MoÅ¼liwe kolory
kolor(czerwony).
kolor(zielony).
kolor(niebieski).

% SÄ…siedztwa miÄ™dzy wojewÃ³dztwami
sasiedzi(podkarpackie, lubelskie).
sasiedzi(lubelskie, mazowieckie).
sasiedzi(mazowieckie, podlaskie).
sasiedzi(podlaskie, warminsko_mazurskie).
sasiedzi(mazowieckie, warminsko_mazurskie).
sasiedzi(lubelskie, podlaskie).

% Funkcja do sprawdzenia czy kolory siÄ™ rÃ³Å¼niÄ…
rozne(A, B) :- A \= B.

% GÅ‚Ã³wne wywoÅ‚anie
koloruj(Wojewodztwa) :-
    kolor(Podkarpackie),
    kolor(Lubelskie),
    kolor(Mazowieckie),
    kolor(Podlaskie),
    kolor(Warminsko),
    
    rozne(Podkarpackie, Lubelskie),
    rozne(Lubelskie, Mazowieckie),
    rozne(Mazowieckie, Podlaskie),
    rozne(Podlaskie, Warminsko),
    rozne(Mazowieckie, Warminsko),
    rozne(Lubelskie, Podlaskie),
    
    Wojewodztwa = [
        podkarpackie-Podkarpackie,
        lubelskie-Lubelskie,
        mazowieckie-Mazowieckie,
        podlaskie-Podlaskie,
        warminsko_mazurskie-Warminsko
    ].

?- koloruj(W).

Zadanie 3

Napisz program obliczajÄ…cy najwiÄ™kszy wspÃ³lny dzielnik dwÃ³ch dodatnich liczb caÅ‚kowitych nww(X, Y, Nww) za pomocÄ… algorytmu Euklidesa z odejmowaniem wg algorytmu zapisanego imperatywnie:

Zadanie 3

Napisz program obliczajÄ…cy najwiÄ™kszy wspÃ³lny dzielnik dwÃ³ch dodatnich liczb caÅ‚kowitych nww(X, Y, Nww) za pomocÄ… algorytmu Euklidesa z odejmowaniem wg algorytmu zapisanego imperatywnie:



function nww(x, y)
	while x â‰  y do
		if x > y then x := x â€“ y
		else y := y â€“ x
	return x

nwd(X, Y, Nwd) :-
    X = Y,
    Nwd = X.

nwd(X, Y, Nwd) :-
    X > Y,
    X1 is X - Y,
    nwd(X1, Y, Nwd).

nwd(X, Y, Nwd) :-
    Y > X,
    Y1 is Y - X,
    nwd(X, Y1, Nwd).



Zadanie 4

Fabryka produkuje kilka rÃ³Å¼nych produktÃ³w, nazwijmy je p1, p2 i p3. Produkty sÄ… produkowane ze skÅ‚adnikÃ³w, ktÃ³re nazwijmy s1, s2, s3 i s4. Zbuduj prologowÄ… bazÄ™ danych, ktÃ³ra bÄ™dzie przechowywaÅ‚a nastÄ™pujÄ…ce informacje:

a) opis kaÅ¼dego produktu, wyszczegÃ³lniajÄ…cy ktÃ³re skÅ‚adniki sÄ… potrzebne do jego produkcji (na ogÃ³Å‚ produkt nie wymaga uÅ¼ycia wszystkich skÅ‚adnikÃ³w).

b) spis dostÄ™pnych w tej chwili skÅ‚adnikÃ³w.



NastÄ™pnie zdefiniuj dwie relacje:

a) moznaprodukowac(X) â€” stwierdzajÄ…ca, Å¼e fabryka posiada wszystkie skÅ‚adniki potrzebne do wyprodukowania produktu X.

b) potrzebuje(X, Y) â€” stwierdzajÄ…ca, Å¼e produkt X potrzebuje skÅ‚adnika Y.

CaÅ‚oÅ›Ä‡ naleÅ¼y zaprogramowaÄ‡ nie uÅ¼ywajÄ…c bezpoÅ›rednio list.

ProszÄ™ bardzo, oto **kompletna wersja programu w Prologu** dla Zadania 4:

---

### ğŸ”§ **Baza danych: produkty, skÅ‚adniki i dostÄ™pnoÅ›Ä‡**

```prolog
% SkÅ‚adniki potrzebne do produkcji danego produktu
skladnik(p1, s1).
skladnik(p1, s2).

skladnik(p2, s2).
skladnik(p2, s3).

skladnik(p3, s1).
skladnik(p3, s3).
skladnik(p3, s4).

% SkÅ‚adniki dostÄ™pne w magazynie
dostepny(s1).
dostepny(s2).
dostepny(s3).
```

---

### ğŸ“Œ **Relacja: potrzebuje(X, Y)**

```prolog
% Produkt X potrzebuje skÅ‚adnika Y
potrzebuje(X, Y) :- 
    skladnik(X, Y).
```

---

### ğŸ­ **Relacja: moznaprodukowac(X)**

```prolog
% Produkt X moÅ¼na produkowaÄ‡, jeÅ›li wszystkie wymagane skÅ‚adniki sÄ… dostÄ™pne
moznaprodukowac(X) :-
    \+ (skladnik(X, S), \+ dostepny(S)).
```

---

### âœ… **PrzykÅ‚adowe uÅ¼ycie**

```prolog
?- potrzebuje(p2, Y).
Y = s2 ;
Y = s3.

?- moznaprodukowac(p1).
true.

?- moznaprodukowac(p3).
false.
```

---

JeÅ›li chcesz dodaÄ‡ nowy skÅ‚adnik dynamicznie, moÅ¼esz uÅ¼yÄ‡:

```prolog
assertz(dostepny(s4)).
```

A potem:

```prolog
?- moznaprodukowac(p3).
true.
```

Zadanie 5

Wykonaj polecenia:



?- append([olej], [woda], [olej, woda]).

?- append([olej], [woda], Co).

?- append([olej], Co, [olej, woda]).
Jakie zastosowania ma instrukcja append?


Ooo, `append/3` w Prologu to jak szwajcarski scyzoryk do list â€“ dziaÅ‚a w **kaÅ¼dÄ… stronÄ™** i robi za wszystko: sklejanie, dzielenie, sprawdzanie, generowanie. Zaraz Ci rozbijÄ™ te zapytania na czynniki pierwsze jak blender filozofa.

---

### ğŸ“Œ `append/3` â€“ ogÃ³lna skÅ‚adnia

```prolog
append(Lista1, Lista2, Wynik).
```

Znaczy to:
**`Lista1` doklejona do `Lista2` daje `Wynik`**

I teraz:

---

### ğŸ” Zapytania z zadania

#### 1. `?- append([olej], [woda], [olej, woda]).`

Prolog sprawdza:

> Czy `[olej] ++ [woda] == [olej, woda]`?
> OdpowiedÅº: **tak**, wiÄ™c zwrÃ³ci:

```prolog
true.
```

---

#### 2. `?- append([olej], [woda], Co).`

Tu Prolog szuka listy `Co`, ktÃ³ra powstaje przez sklejenie `[olej]` i `[woda]`.

Daje:

```prolog
Co = [olej, woda].
```

---

#### 3. `?- append([olej], Co, [olej, woda]).`

Tutaj Prolog prÃ³buje rozdzieliÄ‡ `[olej, woda]`, tak aby zaczynaÅ‚a siÄ™ od `[olej]`, a reszta to `Co`.

Daje:

```prolog
Co = [woda].
```

---

### ğŸ’¡ Do czego sÅ‚uÅ¼y `append/3`?

#### ğŸ”¨ Praktyczne zastosowania:

1. **Sklejanie list**

   ```prolog
   append([a, b], [c, d], X). % X = [a, b, c, d]
   ```

2. **Dzielenie listy** (na prefix i suffix)

   ```prolog
   append(X, Y, [a, b, c]). % znajdÅº wszystkie sposoby rozdziaÅ‚u
   ```

3. **Wstawianie elementu do listy**
   (np. miÄ™dzy `L1` i `L2` wstawiasz `X`)

   ```prolog
   append(L1, L2, [a, b, c]),
   append(L1, [X|T], L2).
   ```

4. **Sprawdzanie, czy lista zawiera podlistÄ™**
   (np. czy `[a, b]` wystÄ™puje gdzieÅ› w `[x, a, b, y]`)

   ```prolog
   append(_, [a, b | _], [x, a, b, y]). % true
   ```

5. **Backtrackingowe generowanie kombinacji podziaÅ‚Ã³w**
   Prolog moÅ¼e podaÄ‡ wszystkie moÅ¼liwe sposoby podzielenia listy!

---

### ğŸ¤¯ Podsumowanie:

`append/3` to:

* **uniwersalne narzÄ™dzie do pracy z listami**
* dziaÅ‚a **zarÃ³wno do budowania, jak i analizowania**
* pozwala na **rekurencyjne operacje na listach**
* i jest wykorzystywana **w wielu algorytmach** (np. sortowanie, przeszukiwanie, permutacje)

Chcesz przykÅ‚ad, jak za pomocÄ… `append` zrobiÄ‡ `member/2`, `reverse/2` albo `delete/3`? To dawaj, rozkminimy wszystko.


Zadanie 6

Wykonaj polecenia:



?- select(X,[1,2,3],L).
?- select(a,L,[1,2,3]).
Jakie zastosowanie ma instrukcja select?



Okej, `select/3` w Prologu to taka maÅ‚a, sprytna funkcja do **wyciÄ…gania, wstawiania i testowania obecnoÅ›ci** elementÃ³w w liÅ›cie. Przyjrzyjmy siÄ™ tym zapytaniom i rozÅ‚oÅ¼ymy `select` jak cebulÄ™ â€“ warstwa po warstwie, z Å‚zami radoÅ›ci w oczach.

---

### ğŸ“Œ OgÃ³lna forma

```prolog
select(X, Lista, ListaBezX).
```

Znaczy to:

> **Z listy `Lista` wybierz element `X`, a reszta to `ListaBezX`**

Albo:

> **Dodaj `X` do `ListaBezX`, a otrzymasz `Lista`**

DziaÅ‚a **w obie strony** â€“ to klasyczne prologowe â€wszystko da siÄ™ odwrÃ³ciÄ‡â€.

---

### ğŸ” Polecenia

#### 1. `?- select(X, [1,2,3], L).`

To znaczy:

> "ZnajdÅº element `X` w liÅ›cie `[1,2,3]`, i podaj, co zostaje z listy po jego usuniÄ™ciu."

##### Wyniki:

```prolog
X = 1, L = [2,3] ;
X = 2, L = [1,3] ;
X = 3, L = [1,2] ;
false.
```

**Prolog backtrackuje** i znajduje wszystkie moÅ¼liwoÅ›ci usuniÄ™cia pojedynczego elementu.

---

#### 2. `?- select(a, L, [1,2,3]).`

To znaczy:

> "Do jakiej listy `L` muszÄ™ wstawiÄ‡ `a`, Å¼eby powstaÅ‚o `[1,2,3]`?"

##### Wyniki:

```prolog
L = [a,1,2,3] ;
L = [1,a,2,3] ;
L = [1,2,a,3] ;
L = [1,2,3,a] ;
false.
```

Czyli Prolog znajduje **wszystkie miejsca**, gdzie `a` moÅ¼na wsadziÄ‡, Å¼eby po jego usuniÄ™ciu wrÃ³ciÄ‡ do `[1,2,3]`.

---

### ğŸ’¡ Zastosowania `select/3`

#### ğŸ”§ Do czego siÄ™ przydaje?

1. **Usuwanie elementu z listy**

   ```prolog
   select(2, [1,2,3], X).  % X = [1,3]
   ```

2. **Wstawianie elementu w dowolne miejsce**

   ```prolog
   select(a, L, [1,2,3]).  % L = [1,a,2,3] itd.
   ```

3. **Permutacje!**
   UÅ¼ywa siÄ™ go rekurencyjnie w definicji permutacji listy:

   ```prolog
   perm([], []).
   perm(L, [H|T]) :- select(H, L, R), perm(R, T).
   ```

4. **Backtracking wyboru elementu**
   MoÅ¼na go uÅ¼yÄ‡ do **wybrania jednego elementu z listy** i wykonania na nim operacji, zostawiajÄ…c resztÄ™ do dalszej obrÃ³bki.

5. **RozwiÄ…zywanie problemÃ³w kombinatorycznych** (np. szachy, sudoku, sortowanie, znajdowanie ruchÃ³w itd.)

---

### ğŸ§  Podsumowanie

`select/3` to:

* narzÄ™dzie do **manipulacji listÄ…**
* wspiera **usuwanie, dodawanie, testowanie, generowanie**
* jest **dwukierunkowe**
* idealne do pisania **rekurencyjnych algorytmÃ³w na permutacjach, wyborach, itp.**

Chcesz przykÅ‚ad dziaÅ‚ania permutacji na bazie `select/3`? Albo jak napisaÄ‡ `delete/3` lub `insert/3`? Dawaj, rozsmarujemy to po logice jak masÅ‚o po toÅ›cie.



Zadanie 7

Zdefiniuj predykat naleÅ¼y(X, Lista), ktÃ³ry sprawdza, czy element X naleÅ¼y do listy Lista. Na przykÅ‚ad naleÅ¼y(a, [a, b, c]). powinno zwrÃ³ciÄ‡ true.

nalezy(X, [X|_]).
nalezy(X, [_|T]) :-
    nalezy(X, T).

Zadanie 8

Zdefiniuj predykat dÅ‚ugoÅ›Ä‡(Lista, DÅ‚), ktÃ³ry oblicza dÅ‚ugoÅ›Ä‡ listy Lista i zapisuje jÄ… w DÅ‚.

dlugosc([], 0).
dlugosc([_|T], D) :-
    dlugosc(T, D1),
    D is D1 + 1.


Zadanie 9

Napisz predykat suma(Lista, S), ktÃ³ry oblicza sumÄ™ wszystkich elementÃ³w w liÅ›cie Lista i zapisuje wynik w S.

suma([], 0).
suma([H|T], S) :-
    suma(T, S1),
    S is H + S1.


Zadanie 10

Zdefiniuj predykat ostatni(X, Lista), ktÃ³ry jest prawdziwy, jeÅ›li X jest ostatnim elementem listy Lista.
ostatni(X, [X]).
ostatni(X, [_|T]) :-
    ostatni(X, T).

Zadanie 11

Zdefiniuj predykat odwrÃ³Ä‡(Lista, Odwrocona), ktÃ³ry zwraca listÄ™ w odwrotnej kolejnoÅ›ci. Na przykÅ‚ad odwrÃ³Ä‡([1,2,3], X) powinno zwrÃ³ciÄ‡ X = [3,2,1].

odwroc([], []).
odwroc([H|T], Odwrocona) :-
    odwroc(T, R),
    append(R, [H], Odwrocona).







